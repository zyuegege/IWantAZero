---
title: C/C++基础合集：面向对象
layout: post
date: 2020-06-10 11:24:00 +0800
categories: 秋招
tags:
	- c/c++
	- 面经
	- 秋招
---

关于c++面向对象相关的一些面试常考知识点，许多资料基本都来源与互联网，每一部分都标明了从何处引用，与先关链接。

[TOC]

---

# C++面向对象的三种特性

面向对象的特性：**封装**、**继承**、**多态**

- **封装**: 封装就是隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别，将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，以特定的访问权限来使用类的成员。面相对象的不就是使用程序处理事情时以对象为中心去分析吗，与面向过程不同，面向过程关心处理的逻辑、流程等问题，而不关心事件主体。而面向对象即面向主体，所以我们在解决问题时应该先进行对象的封装。
- **继承**: 继承是面向对象的基本特征之一，继承机制允许创建分等级层次的类。继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。继承之间是子父类的关系，继承机制可以很好的描述一个类的生态，也提高了代码复用率。
- **多态**: 多态同一个行为具有多个不同表现形式或形态的能力。是指一个类实例（对象）的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。

**多态的优点**: (1) 消除类型之间的耦合关系 (2) 可替换性 (3) 可扩充性 (4) 接口性 (5) 灵活性 (6) 简化性。**多态的必要条件**：(1) 继承 (2) 重写(子类继承父类后对父类的方法进行重新定义) (3) 父类引用指向子类对象。简言之，多态其实是在继承的基础上的

以上参考[面向对象的三大基本特征，五大基本原则](https://www.cnblogs.com/fzz9/p/8973315.html)

---

# 面向对象的五大基本原则

1.  单一职责原则（SRP）

    一个类应该有且只有一个去改变它的理由，这意味着一个类应该只有一项工作。

    比如在职员类里，将工程师、销售人员、销售经理这些情况都放在职员类里考虑，其结果将会非常混乱，在这个假设下，职员类里的每个方法都要`if else`判断是哪种情况，从类结构上来说将会十分臃肿。

2.  开放封闭原则（OCP）

    对象或实体应该对扩展开放，对修改封闭。

    更改封闭即是在我们对模块进行扩展时，勿需对源有程序代码和DLL进行修改或重新编译文件！这个原则对我们在设计类的时候很有帮助，坚持这个原则就必须尽量考虑接口封装，抽象机制和多态技术！

3.  里氏替换原则（LSP）

    在对象 `x` 为类型 `T` 时 `q(x)` 成立，那么当 `S` 是 `T` 的子类时，对象 `y` 为类型 `S` 时 `q(y)` 也应成立。（即对父类的调用同样适用于子类）

4.  依赖倒置原则（DIP）

    高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。具体实现应该依赖于抽象，而不是抽象依赖于实现。

    可以这样理解，上面我举例子的时候先说了兔子和绵羊，然后才推出食草动物。但如果我们继续认识了牛、马等食草动物，我们会发现我们需要不断调整食草动物的描述，这样程序会变得僵化，所以我们不应该让子类依赖于实体，不应该让父类模块依赖于子类模块。所以我们需要将食草动物设计为抽象类，即**抽象类或接口**。这样下层只需要实现相应的细节而不会影响父类。

5.  接口隔离原则（ISP）

    不应强迫客户端实现一个它用不上的接口，或是说客户端不应该被迫依赖它们不使用的方法，使用多个专门的接口比使用单个接口要好的多！

    比如，为了减少接口的定义，将许多类似的方法都放在一个接口中，最后会发现，维护和实现接口的时候花了太多精力，而接口所定义的操作相当于对客户端的一种承诺，这种承诺当然是越少越好，越精练越好，过多的承诺带来的就是你的大量精力和时间去维护！

# C++继承和组合

C++程序开发中，设计孤立的类比较容易，设计相互关联的类却比较难，这其中会涉及到两个概念，一个是继承（Inheritance），一个是组合（Composition）。因为二者有一定的相似性，往往令人混淆不清。类的组合和继承一样，是软件重用的重要方式。组合和继承都是有效地利用已有类的资源。但二者的概念和用法不同。

1.  ## 继承

若在逻辑上B 是一种A （is a kind of），则允许B 继承A 的功能，它们之间就是Is-A 关系。如男人（Man）是人（Human）的一种，女人（Woman）是人的一种。那么类Man 可以从类Human 派生，类Woman也可以从类Human 派生。示例程序如下：

```c++
class Human {
};

class Man:public Human{
};

class Woman: public Human{
};
```

在UML的术语中，继承关系被称为泛化（Generalization），类Man和Woman与类Human的UML关系图可描述如下： 

  <img src="https://gitee.com/zyuegege/images/raw/master/imgs/inheritance.png" style="zoom:80%;" />

继承在逻辑上看起来比较简单，但在实际应用上可能遭遇意外。比如在OO界中著名的“鸵鸟不是鸟”和“圆不是椭圆”的问题。这样的问题说明了程序设计和现实世界存在逻辑差异。从生物学的角度，鸵鸟（Ostrich）是鸟（Bird）的一种，既然是Is-A的关系，类COstrich应该可以从类CBird派生。但是鸵鸟不会飞，但从CBird那里继承了接口函数fly，如下所示：

```c++
class CBird{
public:
    virtual void fly(){}
};
 
class COstrich{
public:
    ...
};
```

“圆不是椭圆”同样存在类似的问题，圆从椭圆类继承了无用的长短轴数据成员。所以更加严格的继承应该是：若在逻辑上B是A的一种，并且A的所有功能和属性对B都有意义，则允许B继承A的所有功能和属性。

类继承允许我们根据自己的实现来覆盖重写父类的实现细节，父类的实现对于子类是可见的，所以我们一般称之为**白盒复用**。继承易于修改或扩展那些被复用的实现，但它这种白盒复用却容易破坏封装性。因为这会将父类的实现细节暴露给子类。

2.  ## 组合

若在逻辑上A 是B 的“一部分”（a part of），则不允许B 继承A 的功能，而是要用A和其它东西组合出B，它们之间就是“Has-A关系”。例如眼（Eye）、鼻（Nose）、口（Mouth）、耳（Ear）是头（Head）的一部分，所以类Head 应该由类Eye、Nose、Mouth、Ear 组合而成，不是派生而成。示例程序如下：

```c++
class Eye
{
public:
　　void Look(void);
};
class Nose
{
public:
　　void Smell(void);
};
class Mouth
{
public:
　　void Eat(void);
};
class Ear
{
public:
　　void Listen(void);
};
// 正确的设计，冗长的程序
class Head
{
public:
　　void Look(void) { m_eye.Look(); }
　　void Smell(void) { m_nose.Smell(); }
　　void Eat(void) { m_mouth.Eat(); }
　　void Listen(void) { m_ear.Listen(); }
private:
　　Eye m_eye;
　　Nose m_nose;
　　Mouth m_mouth;
Ear m_ear;
};
```

如果允许Head 从Eye、Nose、Mouth、Ear 派生而成，那么Head 将自动具有Look、Smell、Eat、Listen 这些功能：

```c++
// 错误的设计
class Head : public Eye, public Nose, public Mouth, public Ear {
};
```

上述程序十分简短并且运行正确，但是这种设计却是错误的。所以我们要经的起“继承”的诱惑，避免犯下设计错误。在UML中，上面类的UML关系图可描述如下： 

 <img src="https://gitee.com/zyuegege/images/raw/master/imgs/composition.png" style="zoom:80%;" />

实心菱形代表了一种坚固的关系，被包含类的生命周期受包含类控制，被包含类会随着包含类创建而创建，消亡而消亡。组合属于**黑盒复用**，被包含对象的内部细节对外是不可见的，所以它的封装性相对较好，实现上相互依赖比较小，并且可以通过获取其它具有相同类型的对象引用或指针，在运行期间动态的定义组合。而缺点就是致使系统中的对象过多。

综上所述，Is-A关系用继承表示，Has-A关系用组合表示，GoF在《设计模式》中指出OO设计的一大原则就是：**优先使用对象组合，而不是类继承。**

3.  # 解决“圆不是椭圆”继承问题，杜绝不良继承

封装、继承、多态是面向对象技术的三大机制，封装是基础、继承是关键、多态是延伸。继承是作为关键的一部分，如果我们理解不够深刻，则容易造成程序设计中的不良继承，影响程序质量。上文中“圆不是椭圆”这一著名问题，实际上在数学上圆是一种特殊的椭圆，于是会出现下面的继承：

```c++
class CEllipse{
public:
    void setSize(float x,float y){}
};
 
class CCircle:public CEllipse{};
```

椭圆存在一个设置长短轴的成员函数setSize，而圆则不需要。椭圆能做某些圆不能做的事，所以圆继承自椭圆是不合理的类设计。那么面对“圆是/不是一种椭圆”这个两难的问题，我们如何解决。主要有几下几种方法： 

（1）使用代码技巧来弥补设计缺陷。在子类CCircle中重新定义setSize抛出异常，或终止程序，或做其他的异常处理，但这些技巧会让用户吃惊不已，违背了接口设计的“最小惊讶原则”； 
（2）改变观点，人为圆是不对称的。这对于我们思维严谨的程序员来说，有点不可接受； 
（3）将基类的成员函数setSize删除。但这回影响椭圆对象的正常使用。 
（4）去掉它们之间的继承关系。推荐做法，既然圆继承椭圆是一种不良类设计，我们就应该杜绝。去掉继承关系，并不代表圆与椭圆就没有关系，两个类可以继承自同一个类COvalShape，不过该类不能执行不对称的setSize计算，如下图所示：

```c++
class COvalShape{
public:
    void setSize(float x);
};
 
class  CEllipse:public COvalShape{
public:
    void setSize(float x,float y);
};
 
class CCircle:public COvalShape{
};
```

其中，椭圆增加了特有的setSize(float x,float y)运算。

不良继承出现的根本原因在于对继承的理解不够深刻，错把直觉中的“是一种（Is-A）”当成了学术中的“子类型（subtype）”概念。在继承体系中，派生类对象是可以取代基类对象的。而在椭圆和圆的问题上，椭圆类中的成员函数setSize(x,y)违背了这个可置换性，即Liskov替换原则。

所有不良继承都可以归结为“圆不是椭圆”这一著名具有代表性的问题上。在不良继承中，基类总会有一些额外能力，而派生类却无法满足它。这些额外的能力通常表现为一个或多个成员函数提供的功能。要解决这一问题，要么使基类弱化，要么消除继承关系，需要根据具体情形来选择。

[1,2,3]以上引用[C++继承和组合](https://blog.csdn.net/qq_22080999/article/details/82048108)

---

4.  ## 什么时候用继承？什么时候用组合？

- 如果二者间存在一个**“是”**的关系，**并且一个类要对另外一个类公开所有接口**，那么继承是更好的选择
- 如果二者间存在一个**“有”**的关系，那么首选组合

**没有找到极其强烈无法辩驳的使用继承的利用的时候，一律采用组合**，组合体现为现实层面，继承主要体现在扩展方面，**如果并不是需要一个类的所有东西（包括接口和熟悉），那么就不需要使用继承，使用组合更好**，**如果使用继承，那么必须所有的都继承，如果有的东西你不需要继承但是你继承了，那么这就是滥用继承**。

以上引用[【C++】继承和组合的概念？什么时候用继承？什么时候用组合？](https://www.cnblogs.com/yinbiao/p/11534037.html)

---

# C++构造函数可以是虚函数吗？为什么？

构造函数不能是虚函数。

1.  存储的角度：构造函数不能是虚函数。因为虚函数是由一个虚函数列表维护的，而虚函数表是存放在对象中的，如果一个构造函数是虚函数，这个虚函数列表还没有被创建出来，所以是有问题的。
2.  使用的角度：父类和子类出现同名虚函数称为覆盖   父类指针=new 子类名(...);父类指针->函数名(...);//调用子类的虚函数。而构造函数是创建对象时自动调用的， 不是通过父类的指针或引用调用的。
3.  对析构函数的影响：如果构造函数是虚函数，不能明确的确定其对象，如果析构函数不是虚函数，则无法确定其调用的正确性。
4.  构造函数一个生命周期只执行一次，不是对象的动态行为，不需要为虚函数。
5.  虚函数指针的状态是最后一个调用的函数决定的，如果构造函数设置为虚函数，则一定是调用自己的虚表中构造函数。

以上引用[C++构造函数能否是虚函数的问题](https://blog.csdn.net/sinat_34382237/article/details/79295849)

1.  **虚函数对应一个vtable，这大家都知道，可是这个vtable其实是存储在对象的内存空间的。问题出来了，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。**
2.  构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它。但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。

以上引用[【C++】构造函数不能是虚函数](https://www.cnblogs.com/vincently/p/4754502.html)

---

# 何时将析构函数声明为私有？

当我们将析构函数声明为私有时，就意味着析构函数只能在类域中被调用，无法被外界（包括自己的对象）调用。 表现为：

1.   禁止用户对此类型的变量进行定义，即禁止在栈内存空间内创建此类型的对象。要创建对象，只能用 new 在堆上进行。
2.  禁止用户在程序中使用 `delete` 删除此类型对象。对象的删除只能在类内实现，也就是说只有类的实现者才有可能实现对对象的 `delete`，用户不能随便删除对象。

如果用户想删除对象的话，只能按照类的实现者提供的方法进行。

这样做的动机：比如这样一种情况，你希望在析构之前必须做一些事情，但是用你类的人并不知道，
那么你就可以重新写一个函数，里面把要做的事情全部做完了再调用析构函数。
这样人家只能调用你这个函数析构对象，从而保证了析构前一定会做你要求的动作。

除此之外：这样做还会限制继承。
如果一个类不打算作为基类，通常采用的方案就是将其析构函数声明为`private`。 C++11中可以使用final关键字实现。

样做之后大大限制了用户对此类的使用。一般来说不要这样做；通常这样做是用来达到特殊的目的，比如在 `singleton` 的实现上

以上参考[何时将析构函数声明为私有？](https://www.cnblogs.com/ll-10/p/11277408.html)

---

# 构造函数与析构函数的调用顺序

-   构造时，先调用父类构造函数，再调用子类构造函数
-   析构时，先调用子类析构函数，再调用父类析构函数

## 构造函数的实现细节

1.  子类的构造函数执行流程：
    -   调用父类的构造函数
    -   把子类的虚函数表地址赋值给对象的虚函数表指针
    -   初始化子类的成员变量
    -   执行子类构造函数体
2.  父类的构造函数执行流程：
    -   把父类的虚函数表地址赋值给对象的虚函数表指针
    -   初始化父类的成员变量
    -   执行父类构造函数体

## 析构函数的实现细节

1.  子类的析构函数执行流程：
    -   把子类的虚函数表地址赋值给对象的虚函数表指针
    -   调用函数子类析构函数体
    -   调用父类的析构函数
2.  父类的析构函数执行流程：
    -   把父类的虚函数表地址赋值给对象的虚函数表指针
    -   执行父类析构函数体

## 构造函数调用虚函数

在构造函数或析构函数，调用其他虚函数时，是通过call命令调用函数地址，跟普通函数调用方式一样。编译器对构造函数和析构函数做了特殊处理，但如果通过间接方式调用其他虚函数，就跟普通函数调用虚函数的方式是一样的。

## 在类的函数中如何调用虚函数

调用虚函数，主要是要找到虚函数表指针，以及虚函数在虚函数表中的偏移，然后计算出虚函数的地址。

-   获取到`this`指针的地址。
-   通过`this`指针得到虚函数表地址，一般`this`指针就是指向虚函数表地址。
-   通过函数在虚函数表内的偏移量，加上虚函数表地址，计算出函数的地址。
-   通过`call`命令调用函数

是调用的子类还是父类的虚函数，关键还是要看虚函数表指针指向的是谁的虚函数表。由于构造函数和析构函数，都会把虚函数表指针设置为当前类的虚函数表地址，因此，在构造函数和析构函数中调用的虚函数，都是调用的当前类的函数。构造函数和析构函数，调用其他虚函数时，由于虚函数表指针指向的是当前类的虚函数表，因此，调用的是当前类的函数。而这种实现，容易造成混淆和误解，所以，建议在构造函数和析构函数中应该避免直接或者间接调用其他虚函数。

以上引用[C++的构造函数可以调用其他虚函数吗？](https://zhuanlan.zhihu.com/p/104014640)

---

# 为什么要将析构函数设置为虚函数？

C++中析构函数的作用:

-   析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。
-   析构函数名也应与类名相同，只是在函数名前面加一个位取反符，例如`~stud( )`，以区别于构造函数。它不能带任何参数，也没有返回值（包括`void`类型）。只能有一个析构函数，不能重载。
-   如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会**先调用自定义的析构函数再调用合成的析构函数**），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。

类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。

考虑如下情况：

-   （情况1）用派生类类型指针绑定派生类实例，析构的时候，不管基类析构函数是不是虚函数，都会正常析构
-   （情况2）用基类类型指针绑定派生类实例，析构的时候，如果基类析构函数不是虚函数，则只会析构基类，不会析构派生类对象，从而造成内存泄漏。

为什么会出现这种现象呢，个人认为析构的时候如果没有虚函数的动态绑定功能，就只根据指针的类型来进行的，而不是根据指针绑定的对象来进行，所以只是调用了基类的析构函数；如果基类的析构函数是虚函数，则析构的时候就要根据指针绑定的对象来调用对应的析构函数了。

## 为什么析构函数必须是虚函数？

**将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们`new`一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。**

## 为什么C++默认的析构函数不是虚函数？

C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

以上引用[为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数](https://blog.csdn.net/u013340341/article/details/106323849)、[C++中为什么析构函数是虚函数](https://blog.csdn.net/weixin_30953735/article/details/82633999)

---

# 虚函数

虚函数的作用，用专业术语来解释就是实现[多态性](https://baike.baidu.com/item/多态性)（Polymorphism），多态性是将接口与实现进行分离；用形象的语言来解释就是实现以共同的方法，但因个体差异，而采用不同的策略。简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。

## 虚函数表

对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。

这里我们着重看一下这张虚函数表。C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。

一个实际的例子：

```c++
class Base {
    public:
    virtual void f() { cout << "Base::f" << endl; }
    virtual void g() { cout << "Base::g" << endl; }
    virtual void h() { cout << "Base::h" << endl; }
};
```

*按照上面的说法，我们可以通过*`Base`的实例来得到虚函数表。 **下面是实际例程：**

```c++
typedef void(*Fun)(void); 
Base b;
Fun pFun = NULL;
cout << "虚函数表地址：" << (int*)(&b) << endl;
cout << "虚函数表 — 第一个函数地址：" << (int*)*(int*)(&b) << endl;
// Invoke the first virtual function 
pFun = (Fun)*((int*)*(int*)(&b));
pFun();
```

实际运行经果如下：(Windows XP+VS2003, Linux 2.6.22 + GCC 4.1.3)

```
虚函数表地址：0012FED4
虚函数表 — 第一个函数地址：0044F148
Base::f
```

通过这个示例，我们可以看到，我们可以通过强行把`&b`转成`int *` ，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是`Base::f()`，这在上面的程序中得到了验证（把`int *` 强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用`Base::g()`和`Base::h()`，其代码如下：

```c++
(Fun)*((int*)*(int*)(&b)+0);  // Base::f()
(Fun)*((int*)*(int*)(&b)+1);  // Base::g()
(Fun)*((int*)*(int*)(&b)+2);  // Base::h()
```

用一张图表示：

![img](https://gitee.com/zyuegege/images/raw/master/imgs/o_vtable1.jpg)

注意：在上面这个图中，我在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符`'\0'`一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在WinXP+VS2003下，这个值是`NULL`。而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果`1`，表示还有下一个虚函数表，如果值是`0`，表示是最后一个虚函数表。

下面，我将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。

## 一般继承（无虚函数覆盖）

假设有如下所示的一个继承关系：

![img](https://gitee.com/zyuegege/images/raw/master/imgs/o_Drawing3.jpg)

请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示

![img](https://gitee.com/zyuegege/images/raw/master/imgs/o_vtable2.JPG)

我们可以看到下面几点：

1）虚函数按照其声明顺序放于表中。  
2）父类的虚函数在子类的虚函数前面。

## 一般继承（有虚函数覆盖） 

覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。

![img](https://gitee.com/zyuegege/images/raw/master/imgs/o_Drawing4.jpg)

为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：`f()`。那么，对于派生类的实例，其虚函数表会是下面的一个样子：

![img](https://gitee.com/zyuegege/images/raw/master/imgs/o_vtable3.JPG)

我们从表中可以看到下面几点，

1）覆盖的`f()`函数被放到了虚表中原来父类虚函数的位置。  
2）没有被覆盖的函数依旧。

这样，我们就可以看到对于下面这样的程序:

```c++
Base *b = new Derive();
b->f();
```

由`b`所指的内存中的虚函数表的`f()`的位置已经被`Derive::f()`函数地址所取代，于是在实际调用发生时，是`Derive::f()`被调用了。这就实现了多态。

## 多重继承（无虚函数覆盖）

再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数

![img](https://gitee.com/zyuegege/images/raw/master/imgs/o_Drawing1.jpg)

对于子类实例中的虚函数表，是下面这个样子：

![img](https://gitee.com/zyuegege/images/raw/master/imgs/o_vtable4.JPG)

我们可以看到：

1）  每个父类都有自己的虚表。  
2）  子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）

这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。

## 多重继承（有虚函数覆盖）

如果发生虚函数覆盖的情况，下图中，我们在子类中覆盖了父类的f()函数

![img](https://gitee.com/zyuegege/images/raw/master/imgs/o_Drawing2.jpg)

下面是对于子类实例中的虚函数表的图：

![img](https://gitee.com/zyuegege/images/raw/master/imgs/o_vtable5.jpg)

三个父类虚函数表中的`f()`的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的`f()`了。如：

```c++
Derive d;
Base1 *b1 = &d;
Base2 *b2 = &d;
Base3 *b3 = &d;

b1->f(); //Derive::f()
b2->f(); //Derive::f()
b3->f(); //Derive::f() 

b1->g(); //Base1::g()
b2->g(); //Base2::g()
b3->g(); //Base3::g()
```

## 安全性

### 通过父类型的指针访问子类自己的虚函数

子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到`Base1`的虚表中有`Derive`的虚函数，但我们根本不可能使用下面的语句来调用子类的自有虚函数：

```c++
Base1 *b1 = new Derive();
b1->f1();  //编译出错
```

任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。（关于这方面的尝试，通过阅读后面附录的代码，相信你可以做到这一点）

### 访问non-public的虚函数

如果父类的虚函数是`private`或是`protected`的，但这些非`public`的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。例如：

```c++
class Base {
    private:
            virtual void f() { cout << "Base::f" << endl; 
}; 

class Derive : public Base{
};

typedef void(*Fun)(void);
void main() {
    Derive d;
    Fun  pFun = (Fun)*((int*)*(int*)(&d)+0);
    pFun();
}
```

以上引用[c++虚函数详解（你肯定懂了）](https://blog.csdn.net/lyztyycode/article/details/81326699)

---

# 重载、重写(覆盖)、隐藏(重定义)？

## 重载

重载从`overload`翻译过来，是指同一可访问区内被声明的几个具有不同参数列表（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。

1.  同的范围（在同一个作用域中）
2.  函数名字相同
3.  参数不同列表
4.  virtual 关键字可有可无
5.  返回类型可以不同

```c++
int test();
int test(int a);
int test(int a,double b);
int test(double a,int a);
int test(string s);
```

## 重写(覆盖)

重写翻译自`override`，是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有`virtual`修饰。

1.  不在同一个作用域（分别位于派生类与基类）
2.  函数名字相同
3.  参数相同列表（参数个数，两个参数列表对应的类型）
4.  基类函数必须有 `virtual` 关键字，不能有 `static`，大概是多态的原因吧...
5.  返回值类型（或是协变），否则报错
6.  重写函数的访问修饰符可以不同。尽管 `virtual` 是 `private` 的，派生类中重写改写为 `public`,`protected` 也是可以的

```c++
class Base {
    public:
        void test(int a) {
            cout<<"this is base"<<endl;
        }
};

class Ship:public Base {
    public:
        void test(int a) {
            cout<<"this is Base overwrite function"<<endl;
        }
};
```

## 隐藏(重定义)

隐藏是指派生类的函数屏蔽了与其同名的基类函数。注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。

1.  不在同一个作用域（分别位于派生类与基类）
2.  函数名字相同
3.  返回类型可以不同
4.  参数不同，此时，不论有无`virtual`关键字，基类的函数将被隐藏（注意别与重载混淆）而不是被重写
5.  参数相同，但是基类函数没有`virtual`关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）

```c++
class Base {
    public:
        virtual void test(int a) { //有virtual关键字，参数列表不同
            cout<<"this is base there are different parameters with virtual"<<endl;
        }
        void test1() {
            cout<<"this is base with the same parameters with not virtual"<<endl;
        }
         virtual void test2() {
            cout<<"this is base with the same parameters with virtual"<<endl;
        }
};

class Ship:public Base {
    public:
        void test() {
            cout<<"this is Ship there are different parameters with virtual cover"<<endl;
        }
        void test1() {
            cout<<"this is Ship with the same parameters with not virtual cover"<<endl;
        }
        void test2() {
            cout<<"this is Ship with the same parameters with virtual cover"<<endl;
        }
};
```

## 重载和重写的区别

1.  范围区别：重写和被重写的函数在不同的类中，重载和被重载的函数在同一类中。
2.  参数区别：重写与被重写的函数参数列表一定相同，重载和被重载的函数参数列表一定不同。
3.  `virtual`的区别：重写的基类必须要有`virtual`修饰，重载函数和被重载函数可以被`virtual`修饰，也可以没有。

## 隐藏和重写，重载的区别

1.  与重载范围不同：隐藏函数和被隐藏函数在不同类中。
2.  参数的区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定同；当参数不同时，无论基类中的函数是否被`virtual`修饰，基类函数都是被隐藏，而不是被重写。
3.  类成员函数重载：局部同名函数将隐藏而不是重载全局声明，不引入父类名字空间时子类的同名函数不会和父类的构成重载，静态成员函数可以和非静态成员函数构成重载。

以上引用[c++中重载，重写，覆盖](https://www.cnblogs.com/tianzeng/p/9775672.html)

---

# c++继承

## 内存布局

### c语言中`struct`内存布局

由于C++基于C，所以C++也“基本上”兼容C。特别地，C++规范在`struct`上使用了和C相同的，简**单的内存布局原则：成员变量按其被声明的顺序排列，按具体实现所规定的对齐原则在内存地址上对齐。**所有的C/C++厂商都保证他们的C/C++编译器对于有效的C结构采用完全相同的布局。这里，`A`是一个简单的C结构，其成员布局和对齐方式都一目了然：

```c++
struct A {
    char c;
    int i;
};
```



<img src="https://gitee.com/zyuegege/images/raw/master/imgs/5419476_1312877687eHH7.jpg" alt="img" style="zoom:150%;" />

从上图可见，`A`在内存中占有8个字节，按照声明成员的顺序，前4个字节包含一个字符（实际占用1个字节，3个字节空着，补对齐），后4个字节包含一个整数。`A`的指针就指向字符开始字节处。

### c++特征的c `struct`

当然了，C++不是复杂的C，C++本质上是面向对象的语言：包含 **继承、封装，以及多态** 。原始的C `struct`经过改造，成了面向对象世界的基石——类。除了成员变量外，C++类还可以封装成员函数和其他东西。然而，有趣的是，**除非为了实现虚函数和虚继承引入的隐藏成员变量外，C++类实例的大小完全取决于一个类及其基类的成员变量！成员函数基本上不影响类实例的大小。**

这里提供的`B`是一个C `struct`，然而，该`struct`有一些C++特征：控制成员可见性的“`public`/`protected`/`private`”关键字、成员函数、静态成员，以及嵌套的类型声明。虽然看着琳琅满目，实际上，**只有成员变量才占用类实例的空间**。要注意的是，C++标准委员会不限制由“`public`/`protected`/`private`”关键字分开的各段在实现时的先后顺序，因此，不同的编译器实现的内存布局可能并不相同。**（ 在VC++中，成员变量总是按照声明时的顺序排列）。**

```c++
struct B {
    public:
    int bm1;
    protected:
    int bm2;
    private:
    int bm3;
    static int bsm;
    void bf();
    static void bsf();
    typedef void *bpv;
    struct N{};
};
```

<img src="https://gitee.com/zyuegege/images/raw/master/imgs/5419476_1312877781DdTd.jpg" alt="img" style="zoom:150%;" />

`B`中，为何`static int bsm`不占用内存空间？因为它是**静态成员，该数据存放在程序的数据段**中，不在类实例中。

### 单继承内存布局

C++ 提供继承的目的是在不同的类型之间提取共性。比如，科学家对物种进行分类，从而有种、属、纲等说法。有了这种层次结构，我们才可能将某些具备特定性质的东西归入到最合适的分类层次上，如“怀孩子的是哺乳动物”。由于这些属性可以被子类继承，所以，我们只要知道“鲸鱼、人”是哺乳动物，就可以方便地指出“鲸鱼、人都可以怀孩子”。那些特例，如鸭嘴兽（生蛋的哺乳动物），则要求我们对缺省的属性或行为进行覆盖。C++中的继承语法很简单，在子类后加上`::base`就可以了。下面的`D`继承自基类`C`。

```c++
struct C {
    int c1;
    void cf();
};
```

<img src="https://gitee.com/zyuegege/images/raw/master/imgs/5419476_1312877846ODC4.jpg" alt="img" style="zoom:150%;" />

```c++
struct D: C {
    int d1;
    void df();
};
```

<img src="https://gitee.com/zyuegege/images/raw/master/imgs/5419476_1312877924Z2Of.jpg" alt="img" style="zoom:150%;" />

既然派生类要保留基类的所有属性和行为，自然地，每个派生类的实例都包含了一份完整的基类实例数据。在`D`中，并不是说基类`C`的数据一定要放在`D`的数据之前，只不过这样放的话，能够保证`D`中的`C`对象地址，恰好是`D`对象地址的第一个字节。这种安排之下，**有了派生类`D`的指针，要获得基类`C`的指针，就不必要计算偏移量 了。几乎所有知名的C++厂商都采用这种内存安排（基类成员在前）。在单继承类层次下，每一个新的派生类都简单地把自己的成员变量添加到基类的成员变量之后 。**看看上图，`C`对象指针和`D`对象指针指向同一地址。

### 多继承内存布局

大多数情况下，其实单继承就足够了。但是，C++为了我们的方便，还提供了多重继承。比如，我们有一个组织模型，其中有经理类（分任务），工人类（干活）。那么，对于一线经理类，即既要从上级经理那里领取任务干活，又要向下级工人分任务的角色来说，如何在类层次中表达呢？单继承在此就有点力不胜任。我们可以安排经理类先继承工人类，一线经理类再继承经理类，但这种层次结构错误地让经理类继承了工人类的属性和行为。反之亦然。当然，一线经理类也可以仅仅从一个类（经理类或工人类）继承，或者一个都不继承，重新声明一个或两个接口，但这样的实现弊处太多：多态不可能了；未能重用现有的接口；最严重的是，当接口变化时，必须多处维护。最合理的情况似乎是一线经理从两个地方继承属性和行为——经理类、工人类。C++就允许用多重继承来解决这样的问题：

```c++
struct Manager /*...*/ {
    /* ... */
};

struct Worker /*...*/ {
    /* ... */
};

struct MiddleManager:  Manager, Worker /*, ...*/ {
    /* ... */
};

```

这样的继承将造成怎样的类布局呢？下面我们还是用“字母类”来举例：

```c++
struct E {
    int e1;
    void ef();
};
```

<img src="https://gitee.com/zyuegege/images/raw/master/imgs/5419476_1312877988m266.jpg" alt="img" style="zoom:150%;" />

```c++
struct F: C, E {
    int f1;
    void ff();
};
```

<img src="https://gitee.com/zyuegege/images/raw/master/imgs/5419476_13128780325n5V.jpg" alt="img" style="zoom:150%;" />

结构`F`从`C`和`E`多重继承得来。与**单继承相同的是，`F`实例拷贝了每个基类的所有数据。与单继承不同的是，在多重继承下，内嵌的两个基类的对象指针不可能全都与派生类对象指针相同：**

```c++
F f;
// (void *)&f == (void *)(C *)&f;
// (void *)&f < (void *)(E*)&f;
```

上面那行说明`C`对象指针与`F`对象指针相同，下面那行说明`E`对象指针与`F`对象指针不同。观察类布局，可以看到`F`中内嵌的`E`对象，其指针与`F`指针并不相同。正如后文讨论强制转化和成员函数时指出的，这个偏移量会造成少量的调用开销。

**具体的编译器实现可以自由地选择内嵌基类和派生类的布局。VC++** 按照基类的**声明顺序先排列基类实例数据，最后才排列派生类数据。** 当然，派生类数据本身也是按照声明顺序布局的（**本规则并非一成不变**，我们会看到，当一些基类有虚函数而另一些基类没有时，内存布局并非如此）。

### 虚继承的内存布局

回到我们讨论的一线经理类例子。让我们考虑这种情况：如果经理类和工人类都继承自“雇员类”，将会发生什么？

```c++
struct Employee /* ... */{
    /* ... */
};

struct Manager:  Employee/* , ... */ {
    /* ... */
};

struct Worker : Employee /* , ... */ {
    /* ... */
};

struct MiddleManager:  Manager, Worker /* , ... */ {
    /* ... */
};
```

如果经理类和工人类都继承自雇员类，很自然地，它们每个类都会从雇员类获得一份数据拷贝。**如 果不作特殊处理，一线经理类的实例将含有两个 雇员类实例，它们分别来自两个雇员基类 。**如果雇员类成员变量不多，问题不严重；如果成员变量众多，则那份多余的拷贝将造成实例生成时的严重开销。更糟的是，这两份不同的雇员实例可能分别被修改，造成数据的不一致。因此，我们需要让经理类和工人类进行特殊的声明，说明它们愿意共享一份雇员基类实例数据。很不幸，在C++中，这种“共享继承”被称为**“虚继承”**，把问题搞得似乎很抽象。虚继承的语法很简单，在指定基类时加上`virtual`关键字即可。

```c++
struct Employee /* ... */{
    /* ... */
};

struct Manager:  virtual Employee/* , ... */ {
    /* ... */
};

struct Worker : virtual Employee /* , ... */ {
    /* ... */
};

struct MiddleManager:  Manager, Worker /* , ... */ {
    /* ... */
};
```

使用虚继承，比起单继承和多重继承有更大的实现开销、调用开销。回忆一下，**在单继承和多重继承的情况下，内嵌的基类实例地址比起派生类实例地址来，要么地址相同（单继承，以及多重继承的最靠左基类） ，要么地址相差一个固定偏移量（多重继承的非最靠左基类） 。 然而，当虚继承时，一般说来，派生类地址和其虚基类地址之间的偏移量是不固定的，因为如果这个派生类又被进一步继承的话，最终派生类会把共享的虚基类实例数据放到一个与上一层派生类不同的偏移量处。**请看下例：

```c++
struct G: virtual C {
    int g1;
    void gf();
};
```

<img src="https://gitee.com/zyuegege/images/raw/master/imgs/5419476_13128780806dbk.jpg" alt="img" style="zoom:150%;" />

**`GdGvbptrG`（In G, the displacement of G's virtual base pointer to G）意思是：在`G`中，`G`对象的指针与`G`的虚基类表指针之间的偏移量，在此可见为`0`，因为`G`对象内存布局第一项就是虚基类表指针； `GdGvbptrC`（In G, the displacement of G's virtual base pointer to C）意思是：在`G`中，`C`对象的指针与`G`的虚基类表指针之间的偏移量，在此可见为8。**

```c++
struct H: virtual C {
    int h1;
    void hf();
};
```

<img src="https://gitee.com/zyuegege/images/raw/master/imgs/5419476_1312878118CwgC.jpg" alt="img" style="zoom:150%;" />

```c++
struct I: G, H {
    int i1;
    void _if();
}
```

<img src="https://gitee.com/zyuegege/images/raw/master/imgs/5419476_13128781759JQM.jpg" alt="img"  />

暂时不追究`vbptr`成员变量从何而来。从上面这些图可以直观地看到，在`G`对象中，内嵌的`C`基类对象的数据紧跟在`G`的数据之后，在`H`对象中，内嵌的`C`基类对象的数据也紧跟在`H`的数据之后。但是，在`I`对象中，内存布局就并非如此了。VC++实现的内存布局中，`G`对象实例中`G`对象和`C`对象之间的偏移，不同于`I`对象实例中`G`对象和`C`对象之间的偏移。当使用指针访问虚基类成员变量时，由于指针可以是指向派生类实例的基类指针，所以，编译器不能根据声明的指针类型计算偏移，而必须找到另一种间接的方法，从派生类指针计算虚基类的位置。

**在VC++ 中，对每个继承自虚基类的类实例，将增加一个隐藏的\*“虚基类表指针”（vbptr）\*成员变量，从而达到间接计算虚基类位置的目的。该变量指向一个全类共享的偏移量表，表中项目记录了对于该类 而言，“虚基类表指针”与虚基类之间的偏移量。**
其它的实现方式中，有一种是在派生类中使用指针成员变量。这些指针成员变量指向派生类的虚基类，每个虚基类一个指针。这种方式的优点是：获取虚基类地址时，所用代码比较少。然而，编译器优化代码时通常都可以采取措施避免重复计算虚基类地址。况且，这种实现方式还有一个大弊端：从多个虚基类派生时，类实例将占用更多的内存空间；获取虚基类的虚基类的地址时，需要多次使用指针，从而效率较低等等。

在VC++中，`G`拥有一个隐藏的“虚基类表指针”成员，指向一个虚基类表，该表的第二项是**`GdGvbptrC`。（在`G`中，虚基类对象`C`的地址与`G`的“虚基类表指针”之间的偏移量**（ 当对于所有的派生类来说偏移量不变时，省略“d”前的前缀））。比如，在32位平台上，`GdGvptrC`是8个字节。同样，在`I`实例中的`G`对象实例也有 “虚基类表指针”，不过该指针指向一个适用于“**`G`处于`I`之中”**的虚基类表，表中一项为`IdGvbptrC`，值为20。

观察前面的`G`、`H`和`I`， 我们可以得到如下关于VC++虚继承下内存布局的结论：
1.  首先排列非虚继承的基类实例；
2.  有虚基类时，为每个基类增加一个隐藏的`vbptr`，除非已经从非虚继承的类那里继承了一个`vbptr`；
3.  排列派生类的新数据成员；
4.  在实例最后，排列每个虚基类的一个实例。

**该布局安排使得虚基类的位置随着派生类的不同而“浮动不定”，但是，非虚基类因此也就凑在一起，彼此的偏移量固定不变。**

### 成员变量

介绍了类布局之后，我们接着考虑对不同的继承方式，访问成员变量的开销究竟如何。

1.  **没有继承：** 没有任何继承关系时，访问成员变量和`C`语言的情况完全一样：从指向对象的指针，考虑一定的偏移量即可。

```c++
C * pc;
pc->c1; // *(pc + dCc1) // pc是指向C的指针
```

访问`C`的成员变量`c1`，只需要在`pc`上加上固定的偏移量`dCc1`（在`C`中，`C`指针地址与其`c1`成员变量之间的偏移量值），再获取该指针的内容即可。

2.  **单继承：** 由于派生类实例与其基类实例之间的偏移量是常数0，所以，可以直接利用基类指针和基类成员之间的偏移量关系，如此计算得以简化。

```c++
D* pd;  
pd->c1; // *(pd + dDC + dCc1); // *(pd + dDc1);  
pd->d1; // *(pd + dDd1);  
// D从C单继承，pd为指向D的指针。
```

当访问基类成员`c1`时，计算步骤本来应该为`pd+dDC+dCc1`，即为先计算`D`对象和`C`对象之间的偏移，再在此基础上加上`C`对象指针与成员变量`c1` 之间的偏移量。然而，由于`dDC`恒定为0，所以直接计算`C`对象地址与`c1`之间的偏移就可以了。当访问派生类成员d1时，直接计算偏移量。

3.  **多重继承** ：虽然派生类与某个基类之间的偏移量可能不为0，然而，该偏移量总是一个常数。只要是个常数，访问成员变量，计算成员变量偏移时的计算就可以被简化。可见即使对于多重继承来说，访问成员变量开销仍然不大。

```c++
F* pf;  
pf->c1; // *(pf + dFC + dCc1); // *(pf + dFc1);  
pf->e1; // *(pf + dFE + dEe1); // *(pf + dFe1);  
pf->f1; // *(pf + dFf1);  
// F继承自C和E，pf是指向F对象的指针。
```
a. 访问`C`类成员`c1`时，`F`对象与内嵌`C`对象的相对偏移为0，可以直接计算`F`和`c1`的偏移；
b. 访问`E`类成员`e1`时，`F`对象与内嵌E对象的相对偏移是一个常数，`F`和`e1`之间的偏移计算也可以被简化；
c. 访问F自己的成员`f1`时，直接计算偏移量。

4.  **虚继承： 当类有虚基类时，访问非虚基类的成员仍然是计算固定偏移量的问题。然而，访问虚基类的成员变量，开销就增大了** ，因为必须经过如下步骤才能获得成员变量的地址：
    
    1.  获取“虚基类表指针”；
    2.  获取虚基类表中某一表项的内容；
3.  把内容中指出的偏移量加到“虚基类表指针”的地址上。
    
    然而，事情并非永远如此。正如下面访问`I`对象的`c1`成员那样，**如果不是通过指针访问，而是直接通过对象实例，则派生类的布局可以在编译期间静态获得，偏移量也可以在编译时计算，因此也就不必要根据虚基类表的表项来间接计算了。**

```c++
I* pi;  
pi->c1; // *(pi + dIGvbptr + (*(pi+dIGvbptr))[1] + dCc1);  
pi->g1; // *(pi + dIG + dGg1); // *(pi + dIg1);  
pi->h1; // *(pi + dIH + dHh1); // *(pi + dIh1);  
pi->i1; // *(pi + dIi1);  
I i;  
i.c1; // *(&i + IdIC + dCc1); // *(&i + IdIc1);  

// I继承自G和H，G和H的虚基类是C，pi是指向I对象的指针
```

a. 访问虚基类C的成员c1时，`dIGvbptr`是“在I中，`I`对象指针与`G`的“虚基类表指针”之间的偏移”，`*(pi + dIGvbptr)`是虚基类表的开始地址，`*(pi + dIGvbptr)[1]`是虚基类表的第二项的内容（在`I`对象中，`G`对象的“虚基类表指针”与虚基类之间的偏移），`dCc1`是`C`对象指针与成员变量`c1`之间的偏移；  
b. 访问非虚基类`G`的成员`g1`时，直接计算偏移量；  
c. 访问非虚基类`H`的成员`h1`时，直接计算偏移量；  
d. 访问自身成员`i1`时，直接使用偏移量；  
e. 当声明了一个对象实例，用点`.`操作符访问虚基类成员`c1`时，由于编译时就完全知道对象的布局情况，所以可以直接计算偏移量。

当访问类继承层次中，多层虚基类的成员变量时，情况又如何呢？比如，访问虚基类的虚基类的成员变量时？一些实现方式为：保存一个指向直接虚基类的指针，然后就可以从直接虚基类找到它的虚基类，逐级上推。VC++优化了这个过程。 VC++在虚基类表中增加了一些额外的项，这些项保存了从派生类到其各层虚基类的偏移量。

5.  强制转化：如果没有虚基类的问题，将一个指针强制转化为另一个类型的指针代价并不高昂。如果在要求转化的两个指针之间有“基类-派生类”关系，编译器只需要简单地在两者之间加上或者减去一个偏移量即可（并且该量还往往为0）。

```c++
F* pf;  
(C*)pf; // (C*)(pf ? pf + dFC : 0); // (C*)pf;  
(E*)pf; // (E*)(pf ? pf + dFE : 0);  
```

 `C`和`E`是`F`的基类，将`F`的指针`pf`转化为`C*`或`E*`，只需要将`pf`加上一个相应的偏移量。转化为`C`类型指针`C*`时，不需要计算，因为`F`和`C`之间的偏移量为 0。转化为`E`类型指针`E*`时，必须在指针上加一个非0的偏移常量`dFE`。C ++规范要求`NULL`指针在强制转化后依然为`NULL`，因此在做强制转化需要的运算之前，VC++会检查指针是否为`NULL`。当然，这个检查只有当指针被显示或者隐式转化为相关类型指针时才进行；当在派生类对象中调用基类的方法，从而派生类指针在后台被转化为一个基类的`const this` 指针时，这个检查就不需要进行了，因为在此时，该指针一定不为`NULL`。

正如你猜想的，当继承关系中存在虚基类时，强制转化的开销会比较大。具体说来，和访问虚基类成员变量的开销相当。

```c++
I* pi;  
(G*)pi; // (G*)pi;  
(H*)pi; // (H*)(pi ? pi + dIH : 0);  
(C*)pi; // (C*)(pi ? (pi+dIGvbptr + (*(pi+dIGvbptr))[1]) : 0);  
```

`pi`是指向`I`对象的指针，`G`,`H`是`I`的基类，`C`是`G`,`H`的虚基类

a. 强制转化`pi`为`G*`时，由于`G*`和`I*`的地址相同，不需要计算；  
b. 强制转化`pi`为`H*`时，只需要考虑一个常量偏移；  
c. 强制转化`pi`为`C*`时，所作的计算和访问虚基类成员变量的开销相同，首先得到`G`的虚基类表指针，再从虚基类表的第二项中取出`G`到虚基类`C`的偏移量，最后根据`pi`、虚基类表偏移和虚基类`C`与虚基类表指针之间的偏移计算出`C*`。

**一般说来，当从派生类中访问虚基类成员时，应该先强制转化派生类指针为虚基类指针，然后一直使用虚基类指针来访问虚基类成员变量。这样做，可以避免每次都要计算虚基类地址的开销。**见下例。

```
/* before: */             ... pi->c1 ... pi->c1 ...
/* faster: */ C* pc = pi; ... pc->c1 ... pc->c1 ...
```

前者一直使用派生类指针`pi`，故每次访问`c1`都有计算虚基类地址的较大开销；后者先将`pi`转化为虚基类指针`pc`，故后续调用可以省去计算虚基类地址的开销。

### 成员函数

一个C++成员函数只是类范围内的又一个成员。**`X`类每一个非静态的成员函数都会接受一个特殊的隐藏参数——`this`指针，类型为`X* const`。**该指针在后台初始化为指向成员函数工作于其上的对象。同样，在成员函数体内，成员变量的访问是通过在后台计算与`this`指针的偏移来进行。

<img src="https://gitee.com/zyuegege/images/raw/master/imgs/5419476_1312878228wGI4.jpg" alt="img" style="zoom:150%;" />

```c++
struct P {  
   int p1;  
   void pf(); // new  
   virtual void pvf(); // new  
}; 
```

`P`有一个非虚成员函数`pf()`，以及一个虚成员函数`pvf()`。很明显，虚成员函数造成对象实例占用更多内存空间，因为虚成员函数需要虚函数表指针。这一点以后还会谈到。这里要特别指出的是，声明非虚成员函数不会造成任何对象实例的内存开销。现在，考虑`P::pf()`的定义。

```c++
void P::pf() { // void P::pf([P *const this])  
   ++p1;   // ++(this->p1);  
} 
```

这里`P:pf()`接受了一个**隐藏的`this`指针参数**，对于每个成员函数调用，编译器都会自动加上这个参数。同时，注意成员变量访问也许比看起来要代价高昂一些，因为成员变量访问通过`this`指针进行，在有的继承层次下，`this`指针需要调整，所以访问的开销可能会比较大。然而，从另一方面来说，编译器通常会把`this`指针缓存到寄存器中，所以，成员变量访问的代价不会比访问局部变量的效率更差。
访问局部变量，需要到`SP`寄存器中得到栈指针，再加上局部变量与栈顶的偏移。在没有虚基类的情况下，如果编译器把`this`指针缓存到了寄存器中，访问成员变量的过程将与访问局部变量的开销相似。

####  覆盖成员函数

和成员变量一样，成员函数也会被继承。与成员变量不同的是，通过在派生类中重新定义基类函数，一个派生类可以覆盖，或者说替换掉基类的函数定义。**覆盖是静态 （根据成员函数的静态类型在编译时决定）还是动态 （通过对象指针在运行时动态决定），依赖于成员函数是否被声明为“虚函数”。**

`Q`从`P`继承了成员变量和成员函数。`Q`声明了`pf()`，覆盖了`P::pf()`。`Q`还声明了`pvf()`，覆盖了`P::pvf()`虚函数。`Q`还声明了新的非虚成员函数`qf()`，以及新的虚成员函数`qvf()`。

```c++
struct Q : P {  
   int q1;  
   void pf(); // overrides P::pf  
   void qf(); // new  
   void pvf(); // overrides P::pvf  
   virtual void qvf(); // new  
};  
```

对于**非虚** 的成员函数来说，调用哪个成员函数是在**编译**时，根据`->`操作符左边指针表达式的类型**静态决定** 的。特别地，即使`ppq`指向`Q`的实例，`ppq->pf()`仍然调用的是`P::pf()`，因为`ppq`被声明为`P*`。（注意，`->`操作符左边的指针类型决定隐藏的`this`参数的类型。）

```c++
P p; P* pp = &p; Q q; P* ppq = &q; Q* pq = &q;  
pp->pf(); // pp->P::pf(); // P::pf(pp);  
ppq->pf(); // ppq->P::pf(); // P::pf(ppq);  
pq->pf(); // pq->Q::pf(); // Q::pf((P*)pq); （错误!）  
pq->qf(); // pq->Q::qf(); // Q::qf(pq);  
```

标记“错误”处，`P*`似应为`Q*`。因为`pf`非虚函数，而`pq`的类型为`Q*`，故应该调用到`Q`的`pf`函数上，从而该函数应该要求一个`Q* const`类型的`this`指针。

对于**虚函数**调用来说，调用哪个成员函数在**运行时** 决定。不管`->`操作符左边的指针表达式的类型如何，调用的虚函数都是**由指针实际指向的实例类型所决定**。比如，尽管`ppq`的类型是`P*`，当`ppq`指向`Q`的实例时，调用的仍然是`Q::pvf()`。

```c++
pp->pvf(); // pp->P::pvf(); // P::pvf(pp);  
ppq->pvf(); // ppq->Q::pvf(); // Q::pvf((Q*)ppq);  
pq->pvf(); // pq->Q::pvf(); // Q::pvf((P*)pq); （错误！）  
```

标记“错误”处，`P*`似应为`Q*`。因为`pvf`是虚函数，`pq`本来就是`Q*`，又指向`Q`的实例，从哪个方面来看都不应该是`P*`

为了实现这种机制**，引入了隐藏的`vfptr` 成员变量。** 一个`vfptr`被加入到类中（如果类中没有的话），该`vfptr`指向类的虚函数表（`vftable`）。类中每个虚函数在该类的虚函数表中都占据一项。每项保存一个对于该类适用的虚函数的地址。因此，**调用虚函数的过程如下：取得实例的`vfptr`；通过`vfptr`得到虚函数表的一项；通过虚函数表该项的函数地址间接调用虚函数。**也就是说，在普通函数调用的参数传递、调用、返回指令开销外，虚函数调用还需要额外的开销。

回头再看看`P`和`Q`的内存布局，可以发现，VC++编译器把隐藏的`vfptr`成员变量放在`P`和`Q`实例的开始处。这就使虚函数的调用能够尽量快一些。实际上，**VC++的实现方式是，保证任何有虚函数的类的第一项永远是`vfptr`。**这就可能要求在实例布局时，在基类前插入新的`vfptr`，或者要求在多重继承时，虽然在右边，然而有`vfptr`的基类放到左边没有`vfptr`的基类的前面（如下）。

```c++
class CA  
{   int a;};  
class CB  
{   int b;};  
class CL : public CB, public CA  
{   int c;};  

// 对于CL类，它的内存布局是：
int b;
int a;
int c;

// 但是，改造CA如下：
class CA  {  
   int a;  
   virtual void seta( int _a ) { a = _a; }  
};  

// 对于同样继承顺序的CL，内存布局是：
vfptr;
int a;
int b;
int c;
```

许多C++的实现会共享或者重用从基类继承来的`vfptr`。比如，`Q`并不会有一个额外的`vfptr`，指向一个专门存放新的虚函数`qvf()`的虚函数表。`Qvf`项只是简单地**追加**到`P`的虚函数表的末尾。如此一来，单继承的代价就不算高昂。一旦一个实例有`vfptr`了，它就不需要更多的`vfptr`。新的派生类可以引入更多的虚函数，这些新的虚函数只是简单地在已存在的，“每类一个”的虚函数表的末尾追加新项。

#### 多重继承下的虚函数

如果从多个有虚函数的基类继承，一个实例就有可能包含多个`vfptr`。考虑如下的`R`和`S`类：

```c++
struct R {  
   int r1;  
   virtual void pvf(); // new  
   virtual void rvf(); // new  
};  

struct S : P, R {  
   int s1;  
   void pvf(); // overrides P::pvf and R::pvf  
   void rvf(); // overrides R::rvf  
   void svf(); // new  
};  
```

<img src="https://gitee.com/zyuegege/images/raw/master/imgs/5419476_1312878362w5LY.jpg" alt="img" style="zoom:150%;" />

<img src="https://gitee.com/zyuegege/images/raw/master/imgs/5419476_1312878406xm5N.jpg" alt="img" style="zoom:120%;" />

这里`R`是另一个包含虚函数的类。因为`S`从`P`和`R`多重继承，`S`的实例内嵌`P`和`R`的实例，以及`S`自身的数据成员`S::s1`。注意，**在多重继承下，靠右的基类`R`，其实例的地址和`P`与`S`不同。**`S::pvf`覆盖了`P::pvf()`和`R::pvf()`，`S::rvf()`覆盖了`R::rvf()`。

```c++
S s; S* ps = &s;  
((P*)ps)->pvf(); // (*(P*)ps)->P::vfptr[0])((S*)(P*)ps)  
((R*)ps)->pvf(); // (*(R*)ps)->R::vfptr[0])((S*)(R*)ps)  
ps->pvf();       // one of the above; calls S::pvf()  
```

调用`((P*)ps)->pvf()`时，先到`P`的虚函数表中取出第一项，然后把`ps`转化为`S*`作为`this`指针传递进去；
调用`((R*)ps)->pvf()`时，先到`R`的虚函数表中取出第一项，然后把`ps`转化为`S*`作为`this`指针传递进去；

因为`S::pvf()`覆盖了`P::pvf()`和`R::pvf()`，在`S`的虚函数表中，相应的项也应该被覆盖。然而，我们很快注意到，不光可以用`P*`，还可以用`R*`来调用`pvf()`。问题出现了：`R`的地址与`P`和`S`的地址不同。表达式 `(R*)ps`与表达式`(P*)ps`指向类布局中不同的位置。因为函数`S::pvf`希望获得一个`S*`作为隐藏的`this`指针参数，虚函数必须把`R*`转化为 `S*`。因此，在`S`对`R`虚函数表的拷贝中，`pvf`函数对应的项，指向的是一个“**调整块**”的地址，该调整块使用必要的计算，把`R*`转换为需要的`S*`。

这就是`thunk1: this-= sdPR; goto S::pvf`干的事。先根据`P`和`R`在`S`中的偏移，调整`this`为`P*`，也就是`S*`，然后跳转到相应的虚函数处执行。**在微软VC++实现中，对于有虚函数的多重继承，只有当派生类虚函数覆盖了多个基类的虚函数时，才使用调整块。** 

#### 地址点与逻辑`this`调整

考虑下一个虚函数`S::rvf()`，该函数覆盖了`R::rvf()`。我们都知道`S::rvf()`必须有一个隐藏的`S*`类型的`this`参数。但是，因为也可以用`R*`来调用`rvf()`，也就是说，`R`的`rvf`虚函数槽可能以如下方式被用到：

```c++
((R*)ps)->rvf(); // (*((R*)ps)->R::vfptr[1])((R*)ps)  
```

所以，大多数实现用另一个调整块将传递给`rvf`的`R*`转换为`S*`。还有一些实现在`S`的虚函数表末尾添加一个特别的虚函数项，该虚函数项提供方法，从而可以直接调用`ps->rvf()`，而不用先转换`R*`。MSC++的实现不是这样，MSC++有意将`S::rvf`编译为接受一个指向`S`中嵌套的`R`实例，而非指向`S`实例的指针（我们称这种行为是“给派生类的指针类型与该虚函数第一次被引入时接受的指针类型相同”）。所有这些在后台透明发生，对成员变量的存取，成员函数的`this`指针，都进行逻辑`this`调整。当然，在debugger中，必须对这种`this`调整进行补偿。

```c++
ps->rvf(); // ((R*)ps)->rvf(); // S::rvf((R*)ps)  
```

调用`rvf`虚函数时，直接给入`R*`作为`this`指针。所以，当覆盖非最左边的基类的虚函数时，MSC++一般不创建调整块，也不增加额外的虚函数项。

#### 调整块

正如已经描述的，有时需要调整块来调整`this`指针的值（`this`指针通常位于栈上返回地址之下，或者在寄存器中），在`this`指针上加或减去一个常量偏移，再调用虚函数。某些实现（尤其是基于`cfront`的）并不使用调整块机制。它们在每个虚函数表项中增加额外的偏移数据。每当虚函数被调用时，该偏移数据（通常为0）,被加到对象的地址上，然后对象的地址再作为this指针传入。

```c++
ps->rvf();  
// struct { void (*pfn)(void*); size_t disp; };  
// (*ps->vfptr[i].pfn)(ps + ps->vfptr[i].disp);  
```

当调用`rvf`虚函数时，前一句表示虚函数表每一项是一个结构，结构中包含偏移量；后一句表示调用第`i`个虚函数时，`this`指针使用保存在虚函数表中第i项的偏移量来进行调整。这种方法的缺点是虚函数表增大了，虚函数的调用也更加复杂。现代基于PC的实现一般采用“调整—跳转”技术：

```c++
S::pvf-adjust: // MSC++  
this -= SdPR;  
goto S::pvf()  
```

当然，下面的代码序列更好（然而，当前没有任何实现采用该方法）：

```c++
S::pvf-adjust:  
this -= SdPR; // fall into S::pvf()  
S::pvf() { ... }  
```

IBM的C++编译器使用该方法。

#### 虚继承下的虚函数

`T`虚继承`P`，覆盖`P`的虚成员函数，声明了新的虚函数。如果采用在基类虚函数表末尾添加新项的方式，则访问虚函数总要求访问虚基类。在VC++中，为了避免获取虚函数表时，转换到虚基类P的高昂代价，**`T`中的新虚函数通过一个新的虚函数表 获取**，从而带来了一个新的虚函数表指针。该指针放在`T`实例的顶端。

```c++
struct T : virtual P {  
   int t1;  
   void pvf();         // overrides P::pvf  
   virtual void tvf(); // new  
};  
void T::pvf() {  
   ++p1; // ((P*)this)->p1++; // vbtable lookup!  
   ++t1; // this->t1++;  
}  
```

![img](https://gitee.com/zyuegege/images/raw/master/imgs/5419476_1312878454a1Na.jpg)

如上所示，**即使是在虚函数中，访问虚基类的成员变量也要通过获取虚基类表的偏移，实行计算来进行。这样做之所以必要，是因为虚函数可能被进一步继承的类所覆盖，而进一步继承的类的布局中，虚基类的位置变化了。**下面就是这样的一个类：

```c++
struct U : T {  
   int u1;  
};  
```

![img](https://gitee.com/zyuegege/images/raw/master/imgs/5419476_1312878510F137.jpg)

在此`U`增加了一个成员变量，从而改变了`P`的偏移。因为VC++实现中，`T::pvf()`接受的是嵌套在`T`中的`P`的指针，所以，需要提供一个调整块，把`this`指针调整到`T::t1`之后（该处即是`P`在`T`中的位置）。

#### 特殊成员函数

本节讨论编译器合成到特殊成员函数中的隐藏代码。

##### 构造函数和析构函数

正如我们所见，在构造和析构过程中，有时需要初始化一些隐藏的成员变量。最坏的情况下，一个构造函数要执行如下操作：

1.  如果是“最终派生类”，初始化`vbptr`成员变量，调用虚基类的构造函数；
2.  调用非虚基类的构造函数
3.   调用成员变量的构造函数
4.  初始化虚函数表成员变量
5.  执行构造函数体中，程序所定义的其他初始化代码

（注意：一个“最终派生类”的实例，一定不是嵌套在其他派生类实例中的基类实例）
所以，如果你有一个包含虚函数的很深的继承层次，即使该继承层次由单继承构成，对象的构造可能也需要很多针对虚函数表的初始化。反之，析构函数必须按照与构造时严格相反的顺序来“肢解”一个对象。

1. 合成并初始化虚函数表成员变量
2. 执行析构函数体中，程序定义的其他析构代码
3. 调用成员变量的析构函数（按照相反的顺序）
4. 调用直接非虚基类的析构函数（按照相反的顺序）
5.  如果是“最终派生类”，调用虚基类的析构函数（按照相反顺序）

在VC++中，有虚基类的类的构造函数接受一个隐藏的“最终派生类标志”，标示虚基类是否需要初始化。对于析构函数，VC++采用“分层析构模型”，代码中加入一个隐藏的析构函数，该函数被用于析构包含虚基类的类（对于 “最终派生类”实例而言）；代码中再加入另一个析构函数，析构不包含虚基类的类。前一个析构函数调用后一个。

##### 虚析构函数与`delete`操作符

假如`A`是`B`的父类，

```c++
A* p = new B(); 
```

如果析构函数不是虚拟的，那么，你后面就必须这样才能安全的删除这个指针： 

```c++
delete (B*)p; 
```

但如果构造函数是虚拟的，就可以在运行时动态绑定到`B`类的析构函数，直接： 

```c++
delete p; 
```

就可以了。这就是虚析构函数的作用。 实际上，很多人这样总结：当且仅当类里包含至少一个虚函数的时候才去声明虚析构函数。 考虑结构`V`和`W`。

```c++
struct V {  
   virtual ~V();  
}; 
```

![img](https://gitee.com/zyuegege/images/raw/master/imgs/5419476_1312878556flHW.jpg)

```c++
struct W : V {  
   operator delete();  
};  
```

![img](https://gitee.com/zyuegege/images/raw/master/imgs/5419476_13128785986DxX.jpg)

析构函数可以为虚。**一个类如果有虚析构函数的话，将会象有其他虚函数一样，拥有一个虚函数表指针，虚函数表中包含一项，其内容为指向对该类适用的虚析构函数的地址。这些机制和普通虚函数相同。虚析构函数的特别之处在于：当类实例被销毁时，虚析构函数被隐含地调用。调用地（`delete`发生的地方）虽然不知道销毁的动态类型，然而，要保证调用对该类型合适的`delete`操作符。**例如，当`pv`指向W的实例时，当`W::~W`被调用之后，`W`实例将由`W`类的`delete`操作符来销毁。

```c++
V* pv = new V;  
delete pv;   // pv->~V::V(); // use ::operator delete()  
pv = new W;  
delete pv;   // pv->~W::W(); // use W::operator delete() 动态绑定到 W的析构函数，W默认的析构函数调用{delete this;}  
pv = new W;  
::delete pv; // pv->~W::W(); // use ::operator delete()  
```

`V`没有定义`delete`操作符，`delete`时使用函数库的`delete`操作符；  
`W`定义了`delete`操作符，`delete`时使用自己的`delete`操作符；  
可以用全局范围标示符显示地调用函数库的`delete`操作符。  
为了实现上述语意，VC++扩展了其“分层析构模型”，从而自动创建另一个隐藏的析构帮助函数——“deleting析构函数”，然后，用该函数的地址来替换虚函数表中“实际”虚析构函数的地址。析构帮助函数调用对该类合适的析构函数，然后为该类有选择性地调用合适的`delete`操作符。

### 数组

堆上分配空间的数组使虚析构函数进一步复杂化。问题变复杂的原因有两个：

1.  堆上分配空间的数组，由于数组可大可小，所以，数组大小值应该和数组一起保存。因此，堆上分配空间的数组会分配额外的空间来存储数组元素的个数；
2.  当数组被删除时，数组中每个元素都要被正确地释放，即使当数组大小不确定时也必须成功完成该操作。然而，派生类可能比基类占用更多的内存空间，从而使正确释放比较困难。

```c++
struct WW : W { int w1; };  
pv = new W[m];  
delete [] pv; // delete m W's (sizeof(W) == sizeof(V))  
pv = new WW[n];  
delete [] pv; // delete n WW's (sizeof(WW) > sizeof(V)) 
```

`WW`从`W`继承，增加了一个成员变量，因此，`WW`占用的内存空间比`W`大。然而，不管指针`pv`指向`W`的数组还是`WW`的数组，`delete[]`都必须正确地释放`WW`或`W`对象占用的内存空间。

虽然从严格意义上来说，数组`delete`的多态行为C++标准并未定义，然而，微软有一些客户要求实现该行为。因此，在MSC++中，该行为是用另一个编译器生成的虚析构帮助函数来完成。该函数被称为“向量`delete`析构函数”（因其针对特定的类定制，比如`WW`，所以，它能够遍历数组的每个元素，调用对每个元素适用的析构函数）。

### 异常处理

简单说来，异常处理是C++标准委员会工作文件提供的一种机制，通过该机制，一个函数可以通知其调用者“异常”情况的发生，调用者则能据此选择合适的代码来处理异常。该机制在传统的“函数调用返回，检查错误状态代码”方法之外，给程序提供了另一种处理错误的手段。

因为C++是面向对象的语言，很自然地，C++中用对象来表达异常状态。并且，使用何种异常处理也是基于“抛出的”异常对象的静态或动态类型来决定的。不光如此，既然C++总是保证超出范围的对象能够被正确地销毁，异常实现也必须保证当控制从异常抛出点转换到异常“捕获”点时（栈展开），超出范围的对象能够被自动、正确地销毁。考虑如下例子：

```c++
struct X { X(); }; // exception object class  
struct Z { Z(); ~Z(); }; // class with a destructor  
extern void recover(const X&);  
void f(int), g(int);  
int main() {  
   try {  
      f(0);  
   } catch (const X& rx) {  
      recover(rx);  
   }  
   return 0;  
}  
void f(int i) {  
   Z z1;  
   g(i);  
   Z z2;  
   g(i-1);  
}  
void g(int j) {  
   if (j < 0)  
      throw X();  
}  
```

`X`是异常类，`Z`是带析构函数的工作类，`recover`是错误处理函数，`f`和`g`一起产生异常条件，`g`实际抛出异常。

这段程序会抛出异常。在`main`中，加入了处理异常的`try & catch`框架，当调用`f(0)`时，`f`构造`z1`，调用`g(0)`后，再构造`z2`，再调用`g(-1)`，此时`g`发现参数为负，抛出`X`异常对象。我们希望在某个调用层次上，该异常能够得到处理。既然`g`和`f`都没有建立处理异常的框架，我们就只能希望`main`函数建立的异常处理框架能够处理X异常对象。实际上，确实如此。当控制被转移到`main`中异常捕获点时，从`g`中的异常抛出点到`main`中的异常捕获点之间，该范围内的对象都必须被销毁。在本例中，`z2`和`z1`应该被销毁。
谈到异常处理的具体实现方式，一般情况下，在抛出点和捕获点都使用“表”来表述能够捕获异常对象的类型；并且，实现要保证能够在特定的捕获点真正捕获特定的异常对象；一般地，还要运用抛出的对象来初始化捕获语句的“实参”。通过合理地选择编码方案，可以保证这些表格不会占用过多的内存空间。
异常处理的开销到底如何？让我们再考虑一下函数`f`。看起来f没有做异常处理。`f`确实没有包含`try`，`catch`，或者是`throw`关键字，因此，我们会猜异常处理应该对f没有什么影响。错！编译器必须保证一旦`z1`被构造，而后续调用的任何函数向f抛回了异常，异常又出了`f`的范围时，`z1`对象能被正确地销毁。同样，一旦`z2`被构造，编译器也必须保证后续抛出异常时，能够正确地销毁`z2`和`z1`。
要实现这些“展开”语意，编译器必须在后台提供一种机制，该机制在调用者函数中，针对调用的函数抛出的异常动态决定异常环境（处理点）。这可能包括在每个函数的准备工作和善后工作中增加额外的代码，在最糟糕的情况下，要针对每一套对象初始化的情况更新状态变量。例如，上述例子中，`z1`应被销毁的异常环境当然与`z2`和`z1`都应该被销毁的异常环境不同，因此，不管是在构造`z1`后，还是继而在构造`z2`后，VC++都要分别在状态变量中更新（存储）新的值。
所有这些表，函数调用的准备和善后工作，状态变量的更新，都会使异常处理功能造成可观的内存空间和运行速度开销。正如我们所见，即使在没有使用异常处理的函数中，该开销也会发生。
幸运的是，一些编译器可以提供编译选项，关闭异常处理机制。那些不需要异常处理机制的代码，就可以避免这些额外的开销了。

好了，现在你可以写C++编译器了（开个玩笑）。
在本文中，我们讨论了许多重要的C++运行实现问题。我们发现，很多美妙的C++语言特性的开销很低，同时，其他一些美妙的特性（译者注：主要是和“虚”字相关的东西）将造成较大的开销。C++很多实现机制都是在后台默默地为你工作。一般说来，单独看一段代码时，很难衡量这段代码造成的运行时开销，必须把这段代码放到一个更大的环境中来考察，运行时开销问题才能得到比较明确的答案。

以上引用[C++继承中的内存布局](https://blog.csdn.net/weixin_42665418/article/details/81066891)

## 继承权限

在c++的继承控制中，有三种不同的控制权限，分别是`public`、`protected`和`private`。定义派生类时，若不显示加上这三个关键字，就会使用默认的方式，用`struct`定义的类是默认`public`继承，`class`定义的类是默认`private`继承。这和Java有很大的不同，Java默认使用`public`继承，而且只有公有继承。

1.  使用`public`继承时，派生类内部可以访问基类中`public`和`protected`成员，但是类外只能通过派生类的对象访问基类的`public`成员。  
    （1）基类的public成员在派生类中依然是`public`的。  
    （2）基类中的`protected`成员在派生类中依然是`protected`的。  
    （3）基类中的`private`成员在派生类中不可访问。

2.  使用`protected`继承时，派生类内部可以访问基类中`public`和`protected`成员，并且类外也不能通过派生类的对象访问基类的成员（可以在派生类中添加公有成员函数接口间接访问基类中的`public`和`protected`成员）

    （1）基类的`public`成员在派生类中变为`protected`成员。  
    （2）基类的`protected`成员在派生类中依然是`protected`成员。  
    （3）基类中的`private`成员在派生类中不可访问。  

3.  使用`private`继承时，派生类内部可以访问基类中`public`和`protected`成员，并且类外也不能通过派生类的对象访问基类的成员（可以在派生类中添加公有成员函数接口间接访问基类中的`public`和`protected`成员）  
    （1）基类的`public`成员在派生类中变成`private`成员。  
    （2）基类的`protected`成员在派生类中变成`private`成员。  
    （3）基类的`private`成员在派生类中不可访问。

    为了便于理解，我们用一个表格来说明这几种控制符使用的情况： 

|    派生方式     | 基类的`public`成员  | 基类的`protected`成员 | 基类的`private`成员 |
| :-------------: | :-----------------: | :-------------------: | :-----------------: |
|  `public`派生   |  还是`public`成员   |  还是`protected`成员  |       不可见        |
| `protected`派生 | 变成`protected`成员 |  还是`protected`成员  |       不可见        |
|  `private`派生  |  变成`private`成员  |   变成`private`成员   |       不可见        |

以上引用[C++ 公有继承、保护继承和私有继承的对比详解](https://blog.csdn.net/weixin_28712713/article/details/80967650)

注意：**使用 `using` 关键字可以改变基类成员在派生类中的访问权限，例如将 `public` 改为 `private`、将 `protected` 改为 `public`，`using` 只能改变基类中 `public` 和 `protected` 成员的访问权限，不能改变 `private` 成员的访问权限，因为基类中 `private` 成员在派生类中是不可见的，根本不能使用，所以基类中的 `private` 成员在派生类中无论如何都不能访问。**

以上引用[C++三种继承方式](http://c.biancheng.net/view/2269.html)

## 多继承

 一个类有多个基类,这样的继承关系称为多继承;

```c++
class 派生类名 : 访问控制 基类名1, 访问控制 基类名2, ...
{
    数据成员和成员函数声明
};
```

类 `C` 可以根据访问控制同时继承类 `A` 和类 `B` 的成员，并添加自己的成员:

![img](https://gitee.com/zyuegege/images/raw/master/imgs/1382048-20180509223417307-556498045.png)

1.  多个基类的派生类构造函数可以用初始化列表调用基类构造函数来初始化数据成员
2.  执行顺序与单继承构造函数情况类似。多个直接基类构造函数执行顺序取决于定义派生类时指定的各个继承基类的顺序
3.  一个派生类对象拥有多个直接或间接基类的成员。不同名成员访问不会出现二义性。如果不同的基类有同名成员，派生类对象访问时应加以识别

![img](https://gitee.com/zyuegege/images/raw/master/imgs/1382048-20180509224828244-2086729123.png)

![img](https://gitee.com/zyuegege/images/raw/master/imgs/1382048-20180509224833612-467652937.png)

以上引用[C++之多继承与虚继承](https://www.cnblogs.com/jimodetiantang/p/9017191.html)

## 虚继承

如果一个派生类从多个基类派生，而这些基类又有一个共同的基类，则在对该基类中声明的名字进行访问时，可能产生二义性。 如下图：

![img](https://gitee.com/zyuegege/images/raw/master/imgs/1382048-20180509225219586-185038967.png)

如下图的分析：

![img](https://gitee.com/zyuegege/images/raw/master/imgs/1382048-20180509225317221-165410554.png)

1.  如果一个派生类从多个基类派生，而这些基类又有一个共同的基类，则在对该基类中声明的名字进行访问时，可能产生二义性。
2.  如果在多条继承路径上有一个公共的基类，那么在继承路径的某处汇合点，这个公共基类就会在派生类的对象中产生多个基类子对象。
3.  要使这个公共基类在派生类中只产生一个子对象，必须对这个基类声明为虚继承，使这个基类成为虚基类
4.  虚继承声明使用关键字 `virtual`

如下虚继承示例：

![img](https://gitee.com/zyuegege/images/raw/master/imgs/1382048-20180509225605495-1061567067.png)

![img](https://gitee.com/zyuegege/images/raw/master/imgs/1382048-20180509225612559-284349121.png)

以上引用[C++之多继承与虚继承](https://www.cnblogs.com/jimodetiantang/p/9017191.html)

## 接口继承、实现继承

所谓接口继承，就是派生类只继承函数的接口，也就是声明；而实现继承，就是派生类同时继承函数的接口和实现。我们都很清楚C++中有几个基本的概念，虚函数、纯虚函数、非虚函数。

1.  虚函数

虚函数是指一个类中你希望重载的成员函数，当你用一个基类指针或引用指向一个继承类对象的时候，你调用一个虚函数，实际调用的是继承类的版本。——MSDN

虚函数用来表现基类和派生类的成员函数之间的一种关系.  
虚函数的定义在基类中进行,在需要定义为虚函数的成员函数的声明前冠以关键字 virtual.  
基类中的某个成员函数被声明为虚函数后,此虚函数就可以在一个或多个派生类中被重新定义.  
在派生类中重新定义时,其函数原型,包括返回类型,函数名,参数个数,参数类型及参数的先后顺序,都必须与基类中的原型完全相同.  
虚函数是重载的一种表现形式,是一种动态的重载方式.

2.  纯虚函数

纯虚函数在基类中没有定义，它们被初始化为0。  
任何用纯虚函数派生的类，都要自己提供该函数的具体实现。  
定义纯虚函数  

```c++
virtual void fun(void) = 0;
```

至于为什么要定义这些函数，我们可以将虚函数、纯虚函数和非虚函数的功能与接口继承与实现继承联系起来：

**声明一个纯虚函数（pure virtual）的目的是为了让派生类只继承函数接口，也就是上面说的接口继承。**纯虚函数一般是在不方便具体实现此函数的情况下使用。也就是说基类无法为继承类规定一个统一的缺省操作，但继承类又必须含有这个函数接口，并对其分别实现。但是，在C++中，我们是可以为纯虚函数提供定义的，只不过这种定义对继承类来说没有特定的意义。因为继承类仍然要根据各自需要实现函数。通俗说，纯虚函数就是要求其继承类必须含有该函数接口，并对其进行实现。是对继承类的一种接口实现要求，但并不提供缺省操作，各个继承类必须分别实现自己的操作。

**声明非纯虚函数（impure virtual）的目的是让继承类继承该函数的接口和缺省实现。**与纯虚函数唯一的不同就是其为继承类提供了缺省操作，继承类可以不实现自己的操作而采用基类提供的默认操作。

**声明非虚函数（non-virtual）的目的是为了令继承类继承函数接口及一份强制性实现。**相对于虚函数来说，非虚函数对继承类要求的更为严格，继承类不仅要继承函数接口，而且也要继承函数实现。也就是为继承类定义了一种行为。

**纯虚函数**：要求继承类必须含有某个接口，并对接口函数实现。  
**虚函数**：继承类必须含有某个接口，可以自己实现，也可以不实现，而采用基类定义的缺省实现。  
**非虚函数**：继承类必须含有某个接口，必须使用基类的实现。

虚函数在派生类中重新定义时候，如果返回的是对基类型的引用或是指针，那么派生类的虚函数可以返回基类函数返回类型的派生类引用或指针，而不是一定要求一样的，primer上看到的。

以上引用[[C++]接口继承与实现继承](https://blog.csdn.net/ljinddlj/article/details/1922189)

---

# 抽象基类

有时候我们需要表示一种抽象的概念，但是具体的实现方式可以有很多种，这个时候我们可以使用纯虚函数定义这种抽象概念，含有或未经覆盖直接继承纯虚函数的类时抽象基类。抽象基类负责定义接口，我们不能直接创建一个抽象基类的对象，但是可以创建派生类的对象，前提是这些类覆盖了纯虚函数。

通过在虚函数声明处分号之前添加=0将虚函数定义为纯虚函数，纯虚函数可以有定义，但是函数体必须定义在类的外部。
以上引用[C++抽象基类](https://blog.csdn.net/xiongya8888/article/details/89578189)

---

# 关于`this`指针的理解

先要理解`class`的意思。`class`应该理解为一种类型，象`int`,`char`一样，是用户自定义的类型。用这个类型可以来声明一个变量，比如`int x`, `myclass my`等等。这样就像变量`x`具有`int`类型一样，变量`my`具有`myclass`类型。理解了这个，就好解释`this`了，`my`里的`this` 就是指向`my`的指针。如果还有一个变量`myclass mz`，`mz`的`this`就是指向`mz`的指针。 这样就很容易理解`this` 的类型应该是`myclass *`,而对其的解引用`*this`就应该是一个`myclass`类型的变量。通常在`class`定义时要用到类型变量自身时，因为这时候还不知道变量名（为了通用也不可能固定实际的变量名），就用`this`这样的指针来使用变量自身。 

1.   **this指针的用处: **一个对象的this指针并不是对象本身的一部分，不会影响`sizeof(对象)`的结果。`this`作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上`this`指针，编译器在编译的时候也是加上`this`的，它作为非静态成员函数的隐含形参，对各成员的访问均通过`this`进行。例如，调用`date.SetMonth(9)` <===> `SetMonth(&date, 9)`，`this`帮助完成了这一转换 .在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无需通过成员访问运算符来做到这一点，因为`this`所指的正是这个对象。任何对类成员的直接访问都被看成`this`的隐式使用。`this`的目的总是指向这个对象，所以`this`是一个常量指针，我们不允许改变`this`中保存的地址.
2.  **this指针的使用:**一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 `return *this；`另外一种情况是当参数与成员变量名相同时，如`this->n = n` （不能写成`n = n`）。

**关于**`this`**指针的一个精典回答:**

当你进入一个房子后，你可以看见桌子、椅子、地板等，但是房子你是看不到全貌了。对于一个类的实例来说，你可以看到它的成员函数、成员变量，但是实例本身呢？`this`是一个指针，它时时刻刻指向你这个实例本身。

以上引用[C++类中this指针的理解](https://blog.csdn.net/chenyt01/article/details/51316022)